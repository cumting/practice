<!DOCTYPE html>
<html lang="en">

	<head>
		<meta charset="UTF-8">
		<title>Title</title>
		<!--<script src="https://code.jquery.com/jquery-2.2.4.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.0.2/js/swiper.js"></script>-->
		<link rel="shortcut icon" href="" type="image/x-icon" />
		<style type="text/css">

		</style>
		<style>
			div {
				direction: rtl;
			}
		</style>

	</head>

	<body>

		<script>
			function Graph(v) {
				this.vertices = v //顶点数目
				this.edges = 0 //总边数
				this.adj = []
				for(var i = 0; i < this.vertices; i++) {
					this.adj[i] = []
				}
				this.addEdge = addEdge
				this.showGraph = showGraph
				//深度优先搜索
				this.dfs = dfs
				this.marked = []
				for(var i = 0; i < this.vertices; i++) {
					this.marked[i] = false
				}
				//广度优先搜索
				this.bfs = bfs
				this.edgeTo=[]//存放从一个顶点到下一个顶点的所有边，为最短路径添加
				this.pathTo=pathTo;//用于展示图中链接不同顶点的路径，为最短路径添加
				this.hasPathTo= hasPathTo//是否访问过，为最短路径添加
			}

			function addEdge(v, w) {
				this.adj[v].push(w)
				this.adj[w].push(v)
				this.edges++
			}

			function showGraph() {
				for(var i = 0; i < this.vertices; i++) {
					console.log(i + "=>")
					var content = ""
					for(var j = 0; j < this.vertices; j++) {
						if(this.adj[i][j] != undefined) {
							content += this.adj[i][j] + " "
						}
					}
					console.log(content)
				}
			}
			//深度优先探索
			function dfs(v) {

				this.marked[v] = true;
				if(this.adj[v] != undefined) {
					console.log("visited" + v)
				}
				//如果不这样this会在foreach中成为window
				var self = this
				this.adj[v].forEach(function(i) {

					if(i && !self.marked[i]) {
						self.dfs(i)
					}
				})
			}

			function bfs(s) { //广度优先搜索
				//如果已经进行深度搜索，就需要初始化一下
				for(var i = 0; i < this.vertices; i++) {
					this.marked[i] = false
				}
				//初始化结束
				var queue = [];
				this.marked[s] = true;
				queue.push(s); //添加到队尾
				while(queue.length > 0) {
					var v = queue.shift(); //从队首取出
					if(v != undefined) {
						console.log("访问节点：" + v);
					}
					for(var i = 0; i < this.adj[v].length; i++) {
						var w = this.adj[v]; //找到所选节点的相邻子列表
						for(var j = 0; j < w.length; j++) {
							if(!this.marked[w[j]]) {
								this.edgeTo[w[j]]=v//为最短路径添加
								this.marked[w[j]] = true; //依次访问其相邻子列表
								queue.push(w[j]); //将子列表推送入队列
							}
						}
					}
				}
			}
			//为最短路径添加
			function pathTo(v){
				var source=0;
				if(!this.hasPathTo(v)){
					return undefined
				}
			}
            function hasPathTo(v){
            	return this.marked[v]
            }
			var graph = new Graph(4)
			graph.addEdge(0, 1)
			graph.addEdge(0, 2)
			graph.addEdge(1, 3)
			graph.showGraph()
			graph.dfs(0)
			graph.bfs(0)
		</script>

</html>