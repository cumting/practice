<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>

	<body>
		<p class="health-border" style="text-align:justify;font-size: 14px;color: #666;line-height: 22px;">
			 请您确认被保险人及其住所是否符合以下所有投保条件， 如不符合，请交由核保员单独核保。<br>
			1.被保险人住所地位于中国大陆境内，本产品所约定的4个直辖市及23个省/自治区中的82个城市；<br>
            2.被保险人住所的建筑年限不满25年；<br />
            3.被保险人住所的建筑结构须为混凝土或钢筋混凝土；<br />
            4.被保险人住所及家庭财产的使用仅限以居住为目的；<br />
            5.被保险人住所没有蒙受任何与现时申请投保之保障有关的损失；<br />
            6.被保险房屋具有合法有效的《房地产权证》或《不动产权证书》<br />
            *本人了解并确认被保险人符合以上所有投保条件。
		</p>
	</body>
	<script type="text/javascript">
			//定义类
function Graph(v){
	this.vertices = v; //顶点
	this.vertexList = [];
	this.edges = 0;
	this.adj = [];
	for(var i=0;i<this.vertices;++i){
		this.adj[i] = [];
	};
	//方法
	this.addEdge = addEdge;
	this.showGraph = showGraph;
	this.topSortHelper = topSortHelper;
	this.topSort = topSort;
}
 
//类对应的方法
function addEdge(v,w){
	this.adj[v].push(w);
	this.adj[w].push(v);
	this.edges++;
}
 
 
// 用于显示符号名字而非数字的新函数,打印所有顶点及其相邻顶点列表
function showGraph() {         
	var visited = [];
	for ( var i = 0; i < this.vertices; ++i) {
		var str = '';
		visited.push(this.vertexList[i+1]);
		for ( var j = 0; j < this.vertices; ++j ) {
			if (this.adj[i][j] != undefined) {
				if (visited.indexOf(this.vertexList[j]) < 0) {
					str += this.adj[i][j] + ' ';
				}
			}
 
		}
		console.log(i + '->' + str);
		visited.pop();
	}
}
//显示最短距离路径显示的函数
function showShortDiatance(paths){
	var str = '';                 //以下都为输出顺序的显示
	while (paths.length > 0) {
		if (paths.length > 1) {
			str += paths.pop() + '-';
		}
		else {
			str += paths.pop();
		}
	}
	console.log(str);
}
//拓扑排序
function topSort() {
	var stack = [];
	var visited = [];
	for (var i = 0; i < this.vertices; i++) {
		visited[i] = false;
	}
	for (var i = 0; i < this.vertices; i++) {
		if (visited[i] == false) {
			this.topSortHelper(i, visited, stack);
		}
	}
	for (var i = 0; i < stack.length; i++) {
		// if (stack[i] != undefined && stack[i] !== false) {     //stack[i] = 0，但是0 != false 是true，所有应该用严等于
			console.log(this.vertexList[stack[i]]);
		}
	}
function topSortHelper(v, visited, stack) {
	visited[v] = true;
	for(var w in this.adj[v]) {
		if (!visited[w]) {
			this.topSortHelper(visited[w], visited, stack);
		}
	}
	stack.push(v);
}
 
//测试拓扑结构
g = new Graph(6);
g.addEdge(1, 2);
g.addEdge(2, 5);
g.addEdge(1, 3);
g.addEdge(1, 4);
g.addEdge(0, 1);
g.vertexList = ["CS1", "CS2", "Data Structures",
"Assembly Language", "Operating Systems",
"Algorithms"];
g.showGraph();
g.topSort();
 


	</script>

</html>